-- å¼·åˆ¶æ‹¼å­—ç¸½é–‹é—œï¼ˆç©©å®šç‰ˆï¼šr3ï¼‰
-- æ ¸å¿ƒé‡é»ï¼š
--   1) ä¸å†ç”¨ vim.b[buf] ç•¶é–ï¼Œæ”¹ç”¨å…¨åŸŸè¡¨ locks[bufnr]ï¼Œé¿å… Invalid buffer id
--   2) æ‰€æœ‰å‹•ä½œå‰éƒ½æª¢æŸ¥ buffer / window æ˜¯å¦æœ‰æ•ˆ
--   3) OptionSet å›å‘¼ç”¨ vim.schedule å»¶å¾Œï¼Œé¿é–‹å¤–æ›é—œ buffer çš„ç¬é–“
--   4) åš´æ ¼äº‹ä»¶è¦†è“‹ï¼Œé˜²æ­¢å¤–æ›æŠŠ spell åˆæ‰“é–‹

local aug = vim.api.nvim_create_augroup("SpellGuard", { clear = true })

-- â†“ å¦‚æœä½ è¦ã€Œå…¨éƒ¨é—œé–‰æ‹¼å­—ã€ï¼ŒæŠŠé€™å€‹ç™½åå–®æ¸…ç©ºå³å¯
-- local whitelist = {}  -- å…¨é—œ
local whitelist = {
  -- markdown  = true,    -- æƒ³é–‹å†å–æ¶ˆè¨»è§£
  -- gitcommit = true,    -- æƒ³é–‹å†å–æ¶ˆè¨»è§£
  -- text      = true,    -- æƒ³é–‹å†å–æ¶ˆè¨»è§£
}

-- æ°¸é é—œé–‰æ‹¼å­—çš„ UI/å¤–æ›è¦–çª—
local force_off_fts = {
  lazy = true,
  NvimTree = true,
  help = true,
  alpha = true,
  notify = true,
  qf = true,
  lspinfo = true,
  checkhealth = true,
  TelescopePrompt = true,
  TelescopeResults = true,
  ["dap-repl"] = true,
}
local force_off_prefix = { "dapui_", "neo%-tree", "trouble", "aerial" }

local function in_force_off(ft)
  if force_off_fts[ft] then
    return true
  end
  for _, p in ipairs(force_off_prefix) do
    if ft:match("^" .. p) then
      return true
    end
  end
  return false
end

-- å®‰å…¨æ€§è¼”åŠ©
local function buf_valid(bufnr)
  return type(bufnr) == "number" and bufnr > 0 and vim.api.nvim_buf_is_valid(bufnr)
end
local function win_valid(winid)
  return type(winid) == "number" and winid > 0 and vim.api.nvim_win_is_valid(winid)
end

-- ğŸ”’ å…¨åŸŸé–ï¼ˆé¿å…éè¿´ï¼‰ï¼Œä¸ç”¨ vim.b ä»¥å… buffer è¢«åˆªå°±å ±éŒ¯
local locks = {} -- [bufnr] = true/false

local function with_lock(bufnr, f)
  bufnr = bufnr or vim.api.nvim_get_current_buf()
  if not buf_valid(bufnr) then
    return
  end
  if locks[bufnr] then
    return
  end
  locks[bufnr] = true
  local ok, err = pcall(f, bufnr)
  if not ok then
    vim.schedule(function()
      -- ç”¨ DEBUG é™å™ªï¼›å¿…è¦æ™‚å¯æ”¹ INFO çœ‹å¾—åˆ°æç¤º
      vim.notify("SpellGuard: " .. tostring(err), vim.log.levels.DEBUG)
    end)
  end
  -- ç«‹åˆ»è§£é–å³å¯ï¼›è‹¥æƒ³æ›´ç©©å¯ defer 0msï¼Œä½†é€™è£¡ç›´æ¥è§£
  locks[bufnr] = false
end

-- ä¾è¦å‰‡è¨­å®šï¼ˆé‡å°ã€Œé¡¯ç¤ºè©² buffer çš„æ‰€æœ‰è¦–çª—ã€ï¼‰
local function enforce_spell(bufnr)
  if not buf_valid(bufnr) then
    return
  end
  local ft = vim.bo[bufnr].filetype or ""
  local want
  if in_force_off(ft) then
    want = false
  else
    want = whitelist[ft] == true
  end
  for _, win in ipairs(vim.api.nvim_list_wins()) do
    if win_valid(win) and vim.api.nvim_win_get_buf(win) == bufnr then
      vim.api.nvim_set_option_value("spell", want, { scope = "local", win = win })
    end
  end
end

-- â˜… å°æ‰€æœ‰å¯è¦‹è¦–çª—/å…¶å°æ‡‰çš„ buffer å¥—ç”¨ä¸€æ¬¡è¦å‰‡
local function enforce_all_windows()
  for _, win in ipairs(vim.api.nvim_list_wins()) do
    if vim.api.nvim_win_is_valid(win) then
      local buf = vim.api.nvim_win_get_buf(win)
      if buf_valid(buf) then
        with_lock(buf, enforce_spell)
      end
    end
  end
end

-- é€éè‡ªå‹•å‘½ä»¤ï¼Œæ–¼ï¼ˆ1ï¼‰User/Lazy äº‹ä»¶ã€ï¼ˆ2ï¼‰CmdlineLeave äº‹ä»¶ï¼ˆæŒ‰<Enter>éµï¼Œ
-- ä»¤ nvim é—œé–‰ã€è¨Šæ¯å›é¥‹è¦–çª—ã€‘ï¼Œä»¥ä¾¿æŒçºŒå¾Œé¢å°šå¾…åŸ·è¡Œä¹‹ä½œæ¥­ï¼‰è§¸ç™¼å¾Œï¼Œå°‡
-- ã€åªå¥—ç”¨ç›®å‰bufferã€‘æ”¹æˆã€æ‰€æœ‰è¦–çª—ã€‘ã€‚

-- Lazy äº‹ä»¶å¾Œï¼ˆé¿å… Lazy å¤–æ›æŠŠ spell æ‰“é–‹ï¼‰
vim.api.nvim_create_autocmd("User", {
  group = aug,
  pattern = { "VeryLazy", "LazyDone", "LazySync", "LazyInstall", "LazyUpdate" },
  callback = function()
    vim.schedule(function()
      enforce_all_windows()
    end)
  end,
  desc = "SpellGuard: after lazy events (enforce all windows)",
})

-- CmdlineLeave äº‹ä»¶å¾Œï¼ˆé¿å…å¤–æ›æŠŠ spell æ‰“é–‹ï¼‰
vim.api.nvim_create_autocmd("CmdlineLeave", {
  group = aug,
  callback = function()
    vim.schedule(function()
      enforce_all_windows()
    end)
  end,
  desc = "SpellGuard: after cmdline leave (enforce all windows)",
})

-- æ‰€æœ‰äººæ”¹å‹• spell â†’ æˆ‘å€‘å»¶å¾Œ 0ms å†çµ±ä¸€è¦†è“‹ï¼ˆé¿å…ç«¶æ…‹ï¼‰
vim.api.nvim_create_autocmd("OptionSet", {
  group = aug,
  pattern = "spell",
  nested = true,
  callback = function(args)
    local buf = args.buf
    vim.schedule(function()
      if buf_valid(buf) then
        with_lock(buf, enforce_spell)
      end
    end)
  end,
  desc = "SpellGuard: intercept spell toggles",
})

-- é€²å…¥è¦–çª— / é–‹ buffer / è¨­å®š filetypeï¼šå¥—ç”¨ä¸€æ¬¡
vim.api.nvim_create_autocmd({ "WinEnter", "BufWinEnter", "BufEnter", "FileType" }, {
  group = aug,
  callback = function(args)
    if buf_valid(args.buf) then
      with_lock(args.buf, enforce_spell)
    end
  end,
  desc = "SpellGuard: apply on window/buffer/filetype events",
})

-- Lazy æ“ä½œå¾Œå†è£œä¸€æ¬¡ï¼ˆå–ç•¶å‰ bufferï¼‰
vim.api.nvim_create_autocmd("User", {
  group = aug,
  pattern = { "VeryLazy", "LazyDone", "LazySync", "LazyInstall", "LazyUpdate" },
  callback = function()
    local buf = vim.api.nvim_get_current_buf()
    if buf_valid(buf) then
      with_lock(buf, enforce_spell)
    end
  end,
  desc = "SpellGuard: after lazy events",
})

-- å­˜è¨­å®šæª”å¾Œï¼ˆplugins/*.lua ç­‰ï¼‰â†’ å»¶å¾Œè¦†è“‹ï¼Œé¿é–‹é—œçª—/é—œ buffer ç•¶ä¸‹
vim.api.nvim_create_autocmd("BufWritePost", {
  group = aug,
  pattern = { "*.lua", "*.vim" },
  callback = function(args)
    local buf = args.buf
    vim.schedule(function()
      if buf_valid(buf) then
        with_lock(buf, enforce_spell)
      end
    end)
  end,
  desc = "SpellGuard: after saving configs",
})

-- ï¼ˆå¯é¸ï¼‰ä½é »å¿ƒè·³ï¼šé˜²è¬ä¸€ï¼ˆæ¯æ¬¡ CursorHold ä¹Ÿæ‹‰å›ä¾†ï¼‰
vim.api.nvim_create_autocmd("CursorHold", {
  group = aug,
  callback = function()
    local buf = vim.api.nvim_get_current_buf()
    if buf_valid(buf) then
      with_lock(buf, enforce_spell)
    end
  end,
  desc = "SpellGuard: keep consistent on idle",
})

-- å°å·¥å…·
vim.api.nvim_create_user_command("SpellGuardStatus", function()
  local bufnr = vim.api.nvim_get_current_buf()
  local ft = vim.bo[bufnr].filetype or ""
  print(
    ("buf=%d filetype=%s spell=%s (whitelist=%s force_off=%s)"):format(
      bufnr,
      ft,
      tostring(vim.opt_local.spell:get()),
      tostring(whitelist[ft] or false),
      tostring(in_force_off(ft))
    )
  )
end, {})
